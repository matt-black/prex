"""Thin plate spline transformations"""

from itertools import chain, combinations_with_replacement

import jax
import jax.numpy as jnp
from jax.tree_util import Partial
from jaxtyping import Array, Float

from .util import sqdist


def fit_spline(
    x: Float[Array, "n d"],
    y: Float[Array, "n d"],
    alpha: float,
    order: int,
    eps: float = 1e-6,
) -> Float[Array, "p d"]:
    """Fit a polyharmonic spline that will map the data points, `x` to the target points, `y`.

    Args:
        x (Float[Array, "n d"]): data points, of shape (n_obs, n_dim).
        y (Float[Array, "n d"]): matched target points, of shape (n_obs, n_dim)
        alpha (float): regularization parameter. is multiplied by the term that enforces smoothness of the order-th derivatives.
        order (int): order of the spline, will minimize the squared norm of the order-th derivatives. For thin plate splines, use `order=2`.
        eps (float): small parameter to prevent taking logarithms of 0. Defaults to 1e-6.

    Returns:
        Float[Array, "p d"]: parameters for the spline.
    """
    n_obs, n_dim = x.shape
    phi = phs_rbf(x, x, order)
    x_p = polynomial_features(x, order - 1)
    _, n_poly_feat = x_p.shape

    A = jnp.vstack(
        [
            jnp.hstack([phi + alpha * jnp.eye(n_obs, dtype=x.dtype), x_p]),
            jnp.hstack([x_p.T, eps * jnp.eye(n_poly_feat, dtype=x.dtype)]),
        ]
    )
    B = jnp.vstack([y, jnp.zeros((n_poly_feat, n_dim), dtype=x.dtype)])
    return jnp.linalg.solve(A, B)


def transform(
    x: Float[Array, "n d"],
    params: Float[Array, "p d"],
    order: int,
) -> Float[Array, "n d"]:
    """Transform the input data using the parameters of a fitted polyharmonic spline.

    Args:
        x (Float[Array, "n d"]): data to transform.
        params (Float[Array, "p d"]): parameters of the fitted spline, generated by `fit_spline`.
        order (int): order of the fitted spline.

    Returns:
        Float[Array, "n d"]: transformed points
    """
    phi = phs_rbf(x, x, order)
    x_p = polynomial_features(x, order - 1)
    x_aug = jnp.hstack([phi, x_p])
    return x_aug @ params


def phs_rbf(
    x: Float[Array, "n d"], ctrl_pts: Float[Array, "c d"], order: int
) -> Float[Array, "n c"]:
    """Compute pairwise RBF values for input points to the control points.

    Args:
        x (Float[Array, "n d"]): input points
        ctrl_pts (Float[Array, "c d"]): control points
        order (int): order of the radial basis function

    Returns:
        Float[Array, " n"]: distances
    """
    _, dim = ctrl_pts.shape
    pwr = 2 * order - dim
    d = jnp.sqrt(sqdist(x, ctrl_pts))
    return jax.lax.cond(
        pwr % 2 == 0, Partial(_rbf_even, pwr=pwr), Partial(_rbf_odd, pwr=pwr), d
    )


def _rbf_even(dist: Array, pwr: Array) -> Array:
    d = jnp.where(dist == 0, 1, dist)
    return jnp.multiply(jnp.power(dist, pwr), jnp.log(d))


def _rbf_odd(dist: Array, pwr: Array) -> Array:
    return jnp.negative(jnp.power(dist, pwr))


@Partial(jax.jit, static_argnums=(1,))
def polynomial_features(
    x: Float[Array, "n d"], degree: int
) -> Float[Array, "n f"]:
    """Compute polynomial features for the input data.

    Args:
        x (Float[Array, "n d"]): data to compute features of
        degree (int): degree of polynomial

    Returns:
        Float[Array, "n f"]: data transformed to polynomial basis.
    """
    _, n_dim = x.shape
    poly_coeffs = _poly_coeffs(list(_combinations(n_dim, degree)), n_dim)
    return jax.vmap(jax.vmap(_compute_poly_feature, (None, 0)), (0, None))(
        x, poly_coeffs
    )


def _combinations(n_feat: int, degree: int):
    return chain.from_iterable(
        combinations_with_replacement(range(n_feat), i)
        for i in range(degree + 1)
    )


def _poly_coeffs(combos: list[tuple[int, ...]], n_feat: int):
    feats = list(range(n_feat))
    coeffs = []
    for combo in combos:
        coeffs.append([sum([c == f for c in combo]) for f in feats])
    return jnp.asarray(coeffs, dtype=jnp.int32)


def _compute_poly_feature(
    vec: Float[Array, " d"], pow: Float[Array, " d"]
) -> Float[Array, ""]:
    return jnp.prod(jnp.power(vec, pow))
